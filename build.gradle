import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
    id 'com.jfrog.bintray' version '1.6'
    id 'com.github.kt3k.coveralls' version '2.6.3'
    id 'com.marklogic.ml-gradle' version '2.8.0'
    id 'org.sonarqube' version '2.5'
    id 'eclipse'
    id 'groovy'
    id 'idea'
    id 'jacoco'
    id 'java'
    id 'maven-publish'
}

ext {
    // we don't need a REST server, only an XCC server
    mlAppDeployer.getCommands().remove(mlAppDeployer.getCommand('DeployRestApiServersCommand'))
    mlAppConfig {
        name = project.name
        customTokens.put('%%XDBC_PORT%%', '9000')
        createTriggersDatabase = false
    }
}

sourceCompatibility = '1.7'
targetCompatibility = '1.7'

repositories {
    jcenter()
    maven { url 'http://developer.marklogic.com/maven2/' }
}

sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/test/java')
        }
        resources.srcDir file('src/test/resources')
    }
    performanceTest {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir file('src/test/java')
        }
        resources.srcDir file('src/test/resources')
    }
}

configurations {
    integrationTestCompile.extendsFrom testCompile
    integrationTestRuntime.extendsFrom testRuntime

    performanceTestCompile.extendsFrom testCompile
    performanceTestRuntime.extendsFrom testRuntime
}

dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    //api 'org.apache.commons:commons-math3:3.6.1'

    // This dependency is used internally, and not exposed to consumers on their own compile classpath.
    //implementation 'com.google.guava:guava:21.0'
    compile group: 'com.marklogic', name: 'marklogic-xcc', version: '8.0.6'
    compile group: 'xstream', name: 'xstream', version: '1.2.2'
    compile group: 'org.ogce', name: 'xpp3', version: '1.1.6'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}


task sourcesJar(type: Jar, dependsOn: classes) {
    description = "Create a JAR of source files; required by bintray for publishing"
    classifier 'sources'
    from sourceSets.main.allJava
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from 'build/docs/javadoc'
}

test {
    testLogging {
        events TestLogEvent.STARTED,TestLogEvent.PASSED
    }
    //we will run Integration and Performance tests in separate tasks
    exclude '**/*IT*'
    exclude '**/*PT*'
}

jacocoTestReport {
    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}

task integrationTest(type: Test, dependsOn: test) {
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    filter {
        //include all integration tests
        includeTestsMatching "*IT"
    }
    testLogging {
        events TestLogEvent.STARTED,TestLogEvent.PASSED
    }
    //If you want to ensure that integration tests are run every time when you invoke
    //this task, uncomment the following line.
    //outputs.upToDateWhen { false }
    jacoco {
        //coverage report will include both unit and integration tests
        append = true
        destinationFile = file("$buildDir/jacoco/test.exec")
    }
    //generate the Jacoco report
    finalizedBy { tasks.integrationTestReport }
}

task integrationTestReport(type: JacocoReport) {
    sourceSets sourceSets.main
    executionData integrationTest
}

task performanceTest(type: Test) {
    testClassesDir = sourceSets.performanceTest.output.classesDir
    classpath = sourceSets.performanceTest.runtimeClasspath
    filter {
        //include all performance tests
        includeTestsMatching "*PT"
    }
    testLogging {
        events TestLogEvent.STARTED,TestLogEvent.PASSED
    }

    //If you want to ensure that performance tests are run every time when you invoke
    //this task, uncomment the following line.
    outputs.upToDateWhen { false }
}

check.dependsOn jacocoTestReport
//Ensure that the check task fails the build if there are failing integration tests.
check.dependsOn integrationTest
//Ensure that our unit tests are run before our integration tests
integrationTest.mustRunAfter test
integrationTest.onlyIf { !project.hasProperty('skipIntegrationTest') }
//Ensure that the check task fails the build if there are failing performance tests.
//check.dependsOn performanceTest
//Ensure that our unit tests are run before our performance tests
performanceTest.mustRunAfter integrationTest
performanceTest.onlyIf { !project.hasProperty('skipPerformanceTest') }

tasks.withType(Test) {
    reports.html.destination = file("${reporting.baseDir}/${name}")
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.PASSED,
                TestLogEvent.FAILED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        showExceptions true
        exceptionFormat TestExceptionFormat.SHORT
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.PASSED,
                    TestLogEvent.FAILED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_OUT,
                    TestLogEvent.STANDARD_ERROR
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }
        }
    }
}

tasks.coveralls {
    dependsOn 'check'
}

publishing {
    publications {
        mainJava(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
            pom.withXml {
                asNode().children().last() + {
                    resolveStrategy = Closure.DELEGATE_FIRST
                    //groupId = project.group
                    //artifactId = project.name
                    //version = project.version
                    name project.name
                    url project.websiteUrl
                    scm {
                        url project.vcsUrl
                    }
                    issueManagement {
                        system 'GitHub Issues'
                        url project.issueTrackerUrl
                    }
                    inceptionYear '2010'
                    licenses {
                        license {
                            name 'The Apache Software License, Version 2.0'
                            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            distribution 'repo'
                        }
                    }
                    description 'XQSync is a Java command-line tool. The entry point is the main method in the com.marklogic.ps.xqsync.XQSync class. This class takes zero or more property files as its arguments. Any specified system properties will override file-based properties, and properties found in later files may override properties specified in earlier files on the command line.'
                    developers {
                        developer {
                            name 'Mads Hansen'
                            email 'mads.hansen@marklogic.com'
                            organization 'MarkLogic'
                        }
                    }
                }
            }
        }
    }
}

/*
 * In order to publish to bintray, you need an account. Once you have that account, set myBintrayUser and myBintrayKey
 * to your username and key. You can do that in the project gradle.properties file, but it's better to do so in your
 * ~/.gradle/gradle.properties file.
 *
 * Once you do that, you can run "gradle -i bintray" to publish it to bintray.
 */
if (project.hasProperty("myBintrayUser")) {
    bintray {
        user = myBintrayUser
        key = myBintrayKey
        publications = ['mainJava']
        //dryRun = true
        pkg {
            repo = 'maven'
            name = project.name
            licenses = ['Apache-2.0']
            userOrg = 'marklogic'
            websiteUrl = "${project.websiteUrl}"
            issueTrackerUrl = "${project.issueTrackerUrl}"
            vcsUrl = "${project.vcsUrl}"
            githubRepo = 'marklogic-community/xqsync'
            githubReleaseNotesFile = 'README.md'
            version {
                name = project.version
                released = new Date()
            }
        }
    }
}
